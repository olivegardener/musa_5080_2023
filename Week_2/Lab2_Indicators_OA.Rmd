---
title: "Lab 2: Why Start With Indicators?"
author: "Matt Harris & Michael Fichman"
date: '2022-08-22'
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup clear environment, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
```

### Load packages and functions

```{r setup packages, warning = FALSE, eval = FALSE}
# Load Libraries

library(tidyverse)
library(tidycensus)
library(sf)
library(kableExtra)
library(RSocrata)
library(dplyr)
library(stringr)

# we don't want scientific notation
options(scipen=999)

# set default class to return the spatial data as sf objects by default
options(tigris_class = "sf")

# load custom functions from the book
source("https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/functions.r")

palette5 <- c("#f0f9e8","#bae4bc","#7bccc4","#43a2ca","#0868ac")
```

### Use `get_acs()` to get 2016 ACS data

```{r results='hide'}
census_api_key("a3ebdf1648b7fb21df55df7246d9642f040c0ee0", overwrite = TRUE)

tracts16 <-  
  get_acs(geography = "tract",
          variables = c("B25026_001E","B02001_002E",
                        "B15001_050E","B15001_009E",
                        "B19013_001E", "B25058_001E",
                        "B06012_002E"), 
          year=2016, state=06,
          county=075, geometry=TRUE) %>% 
  st_transform('EPSG:7132')
```

Filter out census tracts that do not share edges with other tracts (remove islands)
```{r spatial filtering}
# Get the shapefile for San Francisco County
sf_county <- tigris::counties(state = "CA", cb = TRUE) %>%
  filter(NAME == "San Francisco")

# Convert to sf object
sf_county_sf <- st_as_sf(sf_county)

# Convert mutipolygon to polygon
sf_county_sf <- st_cast(sf_county_sf, "POLYGON")

# Keep only the largest one
sf_county_sf <- sf_county_sf[which.max(st_area(sf_county_sf)), ] %>% 
  st_transform('EPSG:7132')

# Create a logical vector where TRUE means the tract intersects with babybaby
intersects_with <- st_intersects(tracts16, sf_county_sf, sparse = FALSE) %>% apply(1, any)

# Subset tracts_sf with the logical vector
tracts16 <- tracts16[intersects_with, ]

```

Let's examine each variable and the elements of an sf object

```{r}
glimpse(tracts16)
```

We create a new data frame consisting only of population

```{r}
totalPop16 <- tracts16 %>%
  filter(variable == "B25026_001")
```


### Using ggplot to map census data with {sf}

Each plot adds more and more nuance and information

Examine each to see what we've added each time

Consult the textbook to understand the symbology schemes.

(Note: the `qBr()` function used here is an update to the one used
version used in the text book so the results may appear different.)

```{r plots}
A <- 
  ggplot() +
  geom_sf(data = totalPop16, aes(fill = estimate)) +
  theme(
    plot.title = element_text(size=22))

B <- 
  ggplot() +
  geom_sf(data = totalPop16, aes(fill = q5(estimate))) +
  theme(plot.title = element_text(size=22)) 

C <-
  ggplot() +
  geom_sf(data = totalPop16, aes(fill = q5(estimate))) +
  scale_fill_manual(values = palette5,
                    labels = qBr(totalPop16, "estimate"),
                    name = "Total\nPopluation\n(Quintile Breaks)") +
  theme(plot.title = element_text(size=22))

D <- 
  ggplot() +
  geom_sf(data = totalPop16, aes(fill = q5(estimate))) +
  scale_fill_manual(values = palette5,
                    labels = qBr(totalPop16, "estimate"),
                    name = "Popluation\n(Quintile Breaks)") +
  labs(title = "Total Population", subtitle = "Philadelphia; 2016") +
  mapTheme() + 
  theme(plot.title = element_text(size=22))
```

### Working with ACS Data

Here we will modify the 2016 ACS by using `spread()` to widen the data
so that each census variable is now a column. We will use `rename()` to
give sensible names to the columns and we will use `mutate()` to make
new features out of the existing columns. These are all steps we had
introduced in Lab 1, except here we are doing it on {sf} spatial data
frames.

```{r}
# Let's "spread" the data into wide form

tracts16 <- 
  tracts16 %>%
  dplyr::select( -NAME, -moe) %>%
  spread(key = variable, value = estimate) %>%
  rename(TotalPop = B25026_001, 
         Whites = B02001_002,
         FemaleBachelors = B15001_050, 
         MaleBachelors = B15001_009,
         MedHHInc = B19013_001, 
         MedRent = B25058_001,
         TotalPoverty = B06012_002)


# Let's create new rate variables using mutate

tracts16 <- 
  tracts16 %>%
  mutate(pctWhite = ifelse(TotalPop > 0, Whites / TotalPop, 0),
         pctBachelors = ifelse(TotalPop > 0, ((FemaleBachelors + MaleBachelors) / TotalPop), 0),
         pctPoverty = ifelse(TotalPop > 0, TotalPoverty / TotalPop, 0),
         year = "2016") %>%
  dplyr::select(-Whites,-FemaleBachelors,-MaleBachelors,-TotalPoverty)
```

Tracts 2016 is now complete. Let's grab 2020 tracts and do the same
thing.

### 2020 Census Data

Notice that we are getting "wide" data here in the first place This
saves us the trouble of using "spread". We do this by using the
`output="wide"` argument to `get_acs()`. IN previous code chunks we
split the use of `get_acs()` to download the data from the use of
`mutate()` and other {dplyr} functions. Here we put the entire process
into one continuous sequence of code using the "pipe" operator `%>%`.

```{r results='hide'}
tracts20 <- 
  get_acs(geography = "tract", 
          variables = c("B25026_001E","B02001_002E",
                        "B15001_050E","B15001_009E",
                        "B19013_001E","B25058_001E",
                        "B06012_002E"), 
          year=2020, state=42, county=101, 
          geometry=TRUE, output="wide") %>%
  st_transform('EPSG:7132') %>%
  rename(TotalPop = B25026_001E, 
         Whites = B02001_002E,
         FemaleBachelors = B15001_050E, 
         MaleBachelors = B15001_009E,
         MedHHInc = B19013_001E, 
         MedRent = B25058_001E,
         TotalPoverty = B06012_002E) %>%
  dplyr::select(-NAME, -starts_with("B")) %>%
  mutate(pctWhite = ifelse(TotalPop > 0, Whites / TotalPop,0),
         pctBachelors = ifelse(TotalPop > 0, ((FemaleBachelors + MaleBachelors) / TotalPop),0),
         pctPoverty = ifelse(TotalPop > 0, TotalPoverty / TotalPop, 0),
         year = "2020") %>%
  dplyr::select(-Whites, -FemaleBachelors, -MaleBachelors, -TotalPoverty) 
```

To combine the 2016 and 2020 data into the same data frame we use
`rbind()`. The "r" in `rbind()` stands for "row". So this function
"binds rows of two or more data frames". Similarity the `cbind()`
function binds columns of data frames, but that function is not used in
this lab.

```{r}

allTracts <- rbind(tracts16,tracts20)
```

### Wrangling Transit Open Data

```{r}

MUNI_Stops <- read.socrata(
  "https://data.sfgov.org/resource/i28k-bkz6.json",
  app_token = "fpOaceiSu5zHVOar6s6P4xNah",
  email     = "oatwood@upenn.edu",
  password  = "viqZi4-jucpuh-zimhas"
)

MUNI_Stops <- MUNI_Stops %>%
  mutate(
    lon = as.numeric(str_extract(shape.coordinates, "[-]?[0-9]*\\.?[0-9]+(?=,)")),
    lat = as.numeric(str_extract(shape.coordinates, "(?<=, )[-]?[0-9]*\\.?[0-9]+"))
  )

# Now convert the dataframe to sf object
MUNI_Stops_sf <- st_as_sf(MUNI_Stops, coords = c("lon", "lat"), crs = 7132)
```


Let's visualize it

```{r}

ggplot() + 
  geom_sf(data=st_union(MUNI_Stops)) +
  geom_sf(data=MUNI_Stops, 
          aes(colour = Line), 
          show.legend = "point", size= 2) +
  scale_colour_manual(values = c("orange","blue")) +
  labs(title="MUNI Stops", 
       subtitle="San Francisco, CA", 
       caption="Figure 2.5") +
  mapTheme()
```

### Relating SEPTA Stops and Tracts

Create buffers (in feet - note the CRS) around Septa stops - Both a
buffer for each stop, and a union of the buffers... and bind these
objects together

Let's do this in pieces to understand this hefty code chunk

We put them in the same data frame... why?

```{r}

septaBuffers <- 
  rbind(
    st_buffer(septaStops, 2640) %>%
      mutate(Legend = "Buffer") %>%
      dplyr::select(Legend),
    st_union(st_buffer(septaStops, 2640)) %>%
      st_sf() %>%
      mutate(Legend = "Unioned Buffer"))
```

Let's examine both buffers by making a "[small
multiples](https://www.juiceanalytics.com/writing/better-know-visualization-small-multiples)"
plot. This type of plot shows multiple views of the same data or
geographic area. We accomplish this by using the `facet_wrap()`
{ggplot2} function on the *Legend* column.

```{r}
ggplot() +
  geom_sf(data=septaBuffers) +
  geom_sf(data=septaStops, show.legend = "point") +
  facet_wrap(~Legend) + 
  labs(caption = "Figure 2.6") +
  mapTheme()
```

### Using the `sf` Package for Spatial operations

Consult the text to understand the difference between these three types
of joins and discuss which is likely appropriate for this analysis

Create an sf object with ONLY the unioned buffer from the `septaBuffers`
spatial data frame.

```{r}
buffer <- filter(septaBuffers, Legend=="Unioned Buffer")
```

### Spatial Intersection of tracts and buffers

In this section, we deep dive a bit into three different ways to achieve
a similar output. Namely, what we are accomplishing is to select the
tracts from `tracts16` that intersect the buffer of transit stop in
`buffer` . The three different ways to think about this operation are:

-   The intersection returns only the areas where both `buffer` and
    `tracts16` polygons overlap. This is often referred to as "clipping"

-   The intersection polygons are returns the full extend of any polygon
    in `tracts16` that touch (or intersect) the `buffer`. There is no
    clipping of the polygons

    -   We will see three different ways to accomplish this particular
        outcome

-   The intersection of polygons to centroids returns the full extent of
    any polygon in `tracts16` that has its center (called a centroid)
    within the `buffer`

The version of spatial intersection you chose will depend on the type of
analysis you are doing. This concept is explained more deeply in the
text book, lecture and labs.

Note: you will likely get a warning about "attribute variables are
assumed..." don't worry about it.

#### Spatial Clipping with `st_intersection()` on polygons

```{r}
clip <- 
  st_intersection(buffer, tracts16) %>%
  dplyr::select(TotalPop) %>%
  mutate(Selection_Type = "Clip")
```

#### Spatial intersection with `st_intersects()` on polygons

Simply, this type of spatial selection returns any polygon that overlaps
or touches the buffer. We try to keep our code examples concise in this
course, but here we show three different ways to achieve the same
outcome.

1.  `selection1` uses `tracts16[buffer,]` uses the least code, but is
    often confusing unless you know the {sf} package well. In this
    usage, the intersecting rows of `tracts16` are selected for by
    indexing on `buffer`. This method is very fast to compute, but hard
    to understand at first.

2.  `selection2` is a longhand way to do the same. This uses
    `tracts16[st_intersects(tracts16, buffer) %>% lengths > 0, ]` to
    spell out all of the steps used in the first method. This can be
    read as: Select all rows of the rows from `tracts16` where
    `st_intersects()` returns a length of greater than zero. Important
    note that this uses `st_intersects()` and not `st_intersection()` as
    in the previous section. This approach is just as fast as approach
    #1, but a little easier to read.

3.  `selection3` takes a different approach and uses `st_join()` with
    the join type of "st_intersects". In this approach we need to follow
    the join with `filter(!is.na(Legend))` to remove the rows of
    `tracts16` where the polygons did not join. These are the polygons
    that did not intersect. This approach is the most readable and
    easiest to understand, but can be slower on large amounts of data.

```{r spatialSelection}

# Do a spatial selection to see which tracts touch the buffer

# approach #1: sub-setting a spatial object with a spatial object using the '[' brackets.
selection1 <- 
  tracts16[buffer,] %>%
  dplyr::select(TotalPop) %>%
  mutate(Selection_Type = "Spatial Selection")

# approach #2: using `st_intersects` as a verbose way to do approach #1
selection2 <- tracts16[st_intersects(tracts16, buffer) %>% lengths > 0, ] %>%
  dplyr::select(TotalPop) %>%
  mutate(Selection_Type = "Spatial Selection")

# approach #3: use `st_join` to do a spatial join and remove the non-intersecting polygons
selection3 <- tracts16 %>% 
  st_join(buffer, join = st_intersects) %>% 
  filter(!is.na(Legend)) %>% 
  dplyr::select(TotalPop) %>%
  mutate(Selection_Type = "Spatial Intersects")
```

#### Spatial intersection with with `st_centroid()` on polygon centroids

Finally, we are using centroids, or the point at the center of a
polygon, to select whether a polygon from `tracts16` intersects the
`buffer`. The steps here are:

1.  convert tract polygons to centroids and to the spatial intersect to
    buffers using the `selection1` approach from above. The resulting
    geometry type is now a point and not a polygon

2.  drop the geometry so that is becomes a regular non-spatial data
    frame

3.  join the original `tracts16` data frame using the `GEOID` as the
    join field. Note that only the `GEOID` column is selected, however
    the polygon spatial features are also joined.

4.  `st_sf()` is a function to turn it back to an {sf} spatial object

5.  finally the `TotalPop` column is selected and a new field of
    `Selection_Type` is added

Note: you will get a warning about "st_centroid assumes attributes..."
don't worry about it.

```{r}
selectCentroids <-
  st_centroid(tracts16)[buffer,] %>%
  st_drop_geometry() %>%
  left_join(., dplyr::select(tracts16, GEOID), by = "GEOID") %>%
  st_sf() %>%
  dplyr::select(TotalPop) %>%
  mutate(Selection_Type = "Select by Centroids")
```

Plotting the results of each method

```{r}
intersections <- rbind(clip, selection1, selectCentroids)

ggplot() +
  geom_sf(data=intersections, aes(fill = TotalPop)) +
  geom_sf(data=septaStops, show.legend = "point") +
  scale_fill_viridis_c() +
  facet_wrap(~Selection_Type) + 
  mapTheme()
```

## Bonus Exercise - Can you create a small multiple map of the three types of operations? (NOT GRADED)

Consult the text for some operations you can try This is to be done in
breakout groups

### Indicator Maps

We do our centroid joins as above, and then do a "disjoin" to get the
ones that *don't* join, and add them all together. Do this operation and
then examine it. What represents the joins/doesn't join dichotomy? Note
that this contains a correct 2016-2020 inflation calculation

```{r}
allTracts.group <- 
  rbind(
    st_centroid(allTracts)[buffer,] %>%
      st_drop_geometry() %>%
      left_join(allTracts) %>%
      st_sf() %>%
      mutate(TOD = "TOD"),
    st_centroid(allTracts)[buffer, op = st_disjoint] %>%
      st_drop_geometry() %>%
      left_join(allTracts) %>%
      st_sf() %>%
      mutate(TOD = "Non-TOD")) %>%
  mutate(MedRent.inf = ifelse(year == "2009", MedRent * 1.14, MedRent)) 

```

Can you try to create the maps seen in the text? The solutions are
contained in "map_exercise.R"

### TOD Indicator Tables

```{r}
allTracts.Summary <- 
  st_drop_geometry(allTracts.group) %>%
  group_by(year, TOD) %>%
  summarize(Rent = mean(MedRent, na.rm = T),
            Population = mean(TotalPop, na.rm = T),
            Percent_White = mean(pctWhite, na.rm = T),
            Percent_Bach = mean(pctBachelors, na.rm = T),
            Percent_Poverty = mean(pctPoverty, na.rm = T))

kable(allTracts.Summary) %>%
  kable_styling() %>%
  footnote(general_title = "\n",
           general = "Table 2.2")
```

Let's make some comparisons and speculate about the willingness to pay
and demographics in these areas 2009-2020 (see the 2000 data in the text
too)

Notice how we pipe the kable() command here

```{r}
allTracts.Summary %>%
  unite(year.TOD, year, TOD, sep = ": ", remove = T) %>%
  gather(Variable, Value, -year.TOD) %>%
  mutate(Value = round(Value, 2)) %>%
  spread(year.TOD, Value) %>%
  kable() %>%
  kable_styling() %>%
  footnote(general_title = "\n",
           general = "Table 2.3")
```

### TOD Indicator Plots

Let's create small multiple plots We use the "gather" command (look this
one up please) To go from wide to long Why do we do this?? Notice we can
"pipe" a ggplot call right into this operation!

```{r}
allTracts.Summary %>%
  gather(Variable, Value, -year, -TOD) %>%
  ggplot(aes(year, Value, fill = TOD)) +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~Variable, scales = "free", ncol=5) +
  scale_fill_manual(values = c("#bae4bc", "#0868ac")) +
  labs(title = "Indicator differences across time and space") +
  plotTheme() + theme(legend.position="bottom")
```

#### Examining three submarkets

```{r}
centerCity <-
  st_intersection(
    st_buffer(filter(septaStops, Line == "El"), 2640) %>% st_union(),
    st_buffer(filter(septaStops, Line == "Broad_St"), 2640) %>% st_union()) %>%
  st_sf() %>%
  mutate(Submarket = "Center City")

el <-
  st_buffer(filter(septaStops, Line == "El"), 2640) %>% st_union() %>%
  st_sf() %>%
  st_difference(centerCity) %>%
  mutate(Submarket = "El")

broad.st <-
  st_buffer(filter(septaStops, Line == "Broad_St"), 2640) %>% st_union() %>%
  st_sf() %>%
  st_difference(centerCity) %>%
  mutate(Submarket = "Broad Street")

threeMarkets <- rbind(el, broad.st, centerCity)
```

You can then bind these buffers to tracts and map them or make small
multiple plots

```{r}
allTracts.threeMarkets <-
  st_join(st_centroid(allTracts), threeMarkets) %>%
  st_drop_geometry() %>%
  left_join(allTracts) %>%
  mutate(Submarket = replace_na(Submarket, "Non-TOD")) %>%
  st_sf() 
```

### Example of using `multipleRingBuffer()` function

```{r}
allTracts <- rbind(tracts20,tracts16)
septa_MRB <- multipleRingBuffer(st_union(septaStops), 47520, 2640)

allTracts.rings <-
  st_join(st_centroid(dplyr::select(allTracts, GEOID, year)),
          septa_MRB) %>%
  st_drop_geometry() %>%
  left_join(dplyr::select(allTracts, GEOID, MedRent, year), 
            by=c("GEOID"="GEOID", "year"="year")) %>%
  st_sf() %>%
  mutate(distance = distance / 5280) #convert to miles



  ggplot() +
    geom_sf(data=septa_MRB) +
    geom_sf(data=septaStops, size=1) +
    geom_sf(data=st_union(tracts20), fill=NA, size=1.2) +
    labs(title="Half mile buffers") +
    mapTheme()

```

